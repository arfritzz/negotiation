Require Import Omega.
Require Import List.
Require Import Lists.ListTactics.
Require Import Ensembles.
(*Require Import Poset.*)

(* The first step is a Negotiation Request.
   Right now, we are not sure exactly what a Request
   will look like so lets just say it is a natural number.
*)

Definition place := nat.

(* The Security Association provides secure data connection
   between two network devices. *)

Definition securityAssociation := nat. 

(* A term is needed for the privicy policy and a Proposal.
   A proposal will be composed of a list of terms that is 
   the target's response to an attestation request. Furthermore,
   before sending the proposal *)

Inductive term : Type :=
| KIM : nat -> term
| USM : nat -> term
| AT : place -> term -> term
| SEQ : term -> term -> term
| PAR : term -> term -> term
| SIG : term -> term.

Definition myterm1 := (KIM 3).
Definition myterm2 := (AT 4).
Definition myterm3 := (SIG (KIM 3)).
Definition myterm4 := (SEQ (KIM 3)).
Definition myterm5 := (PAR (SIG (USM 4))).

(* A request is generated by the appraiser and 
   holds something in it. It is not necessarily evidence yet
   but something else that dictates was the appraiser wants
   to know about the target. For now, I will say that the request
   is composed of certificates that enforce the privacy policy
   of the appraiser. *)

Inductive request (term : Type) := 
| EV : term -> (request term)
| SUM : term -> (request term) -> (request term)
| PROD : term -> (request term) -> (request term).

(* Now, how to create requests *)

Check request.

Definition myrequest1 := request (place).
Definition myrequest2 := request (term).
(*Definition myrequest3 := request (myterm1).*)

(* not sure how to create a request 
   but it must map from Type -> Type. *)

(* A protocol is simply a list of terms *)

(*Inductive protocol : Type :=
| nil
| cons (h : term) (t : list term).*)

Definition protocol := list term.

Notation "x :: l" := (cons x l)
                     (at level 60, right associativity).
Notation "[ ]" := nil.
Notation "[ x ; .. ; y ]" := (cons x .. (cons y nil) ..).

(* What about examples of protocols? *)
(* Not sure which definition works? *)

Definition proposal := (request nat) -> list protocol.

(* If I wanted to say "Compute request 5" idk how to do that
   or where I defined these things in this language. 
  
   Somewhere in PLUS someone came up with the notition of 
   (S (S n)) but where/how did they think to do this? *)

(* After a proposal is generated, the appraiser must then select 
   the appropriate protocol for the attestation manager. 
   This implies there must be some notion of best and some
   notion of worst and that the protocols must be ordered.

   This brings me back to my inital thoughts that I have no idea
   where the notion of ordering should begin. Somehow we must 
   define a hierarcy of protocols in order to make the 
   decision. Maybe a function is the best way to go about 
   establishing an ordering. *)

(* Questions:

  1. Best definition of protocol?
  2. Additional function that sorts the proposals
     ( this would sort based on defined join and meet
       so I need to define the join and meet. How to 
       represent a lattice? )
  3. Is an overarching definition of negotiation necessary?
  4. Where should the privacy policy be defined?

