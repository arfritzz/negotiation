Require Import Omega.
Require Import List.
Require Import Lists.ListTactics.
Require Import Ensembles.
Require Import String.
(* Require Import PartialMap. *)
(*Require Import Poset.*)

(* Before understanding a request, a SA must
   be established using ISAKMP. The goal of
   ISAKMP is to define a procedure for authenticating
   a communicating peer as well as a procedure for key
   generation techniques.

   This is done through a series of headers that describe
   the payload types, and exchange types

 *)

(* Coq Inductive terms are used to create a data structure *)

Inductive SA_param : Type :=
| authMethod (a : string)
| encrypMethod (e : string)
| HMAC (h : string)
| DHgroup (g : nat)
| time (t : nat).

(* Can have one parameter or more than one parameter
   specificed by the SA *) 

Inductive SA : Type :=
| One (p1 : SA_param)
| More (p1 p2 : SA).

Inductive SA_id : Type :=
| SA_ID (n : nat).

Inductive SA_map : Type :=
| SA_empty
| SA_record (i : SA_id) (sa : SA) (m : SA_map).

Definition my_SA_map_base := SA_record (SA_ID 0) (One (time (1200)))  (SA_empty).
Check my_SA_map_base.

Definition SA_update (d: SA_map) (i : SA_id) (t_value : SA) : SA_map :=
  SA_record i t_value d.

Inductive SA_option : Type :=
| Some (sa : SA)
| None.

Definition eqb_id (x1 x2 : SA_id) :=
  match x1, x2 with
  | SA_ID x1, SA_ID x2 => x1 =? x2
  end.

Fixpoint SA_find (x : SA_id) (d : SA_map) : SA_option :=
  match d with
  | SA_empty => None
  | SA_record y r d' => if  eqb_id x y
                     then Some r
                     else SA_find x d'
  end.

Compute SA_find (SA_ID 0) (my_SA_map_base).
Compute SA_find (SA_ID 1) (my_SA_map_base).

(* What can you prove about SA??*)
(* Where do I store the values for the SA? *)
(* We need a delete option for the partial map?
   How should I write that? *)

Definition place := nat.

Inductive term : Type :=
| KIM : nat -> term
| USM : nat -> term
| AT : place -> term -> term
| SEQ : term -> term -> term
| PAR : term -> term -> term
| SIG : term -> term.

Check term.

Definition myterm1 := (KIM 3).
Definition myterm2 := (AT 4 (USM 4)).
Definition myterm3 := (SIG (KIM 3)).
Definition myterm4 := (SEQ (KIM 3)).
Definition myterm5 := (PAR (SIG (USM 4))).

(* A request is generated by the appraiser and 
   holds something in it. It is not necessarily evidence yet
   but something else that dictates was the appraiser wants
   to know about the target. For now, I will say that the request
   is composed of certificates that enforce the privacy policy
   of the appraiser. *)

(*Inductive request (term : Type) := 
| EV : term -> (request term)
| SUM : term -> (request term) -> (request term)
| PROD : term -> (request term) -> (request term). *)

(* I built a data structure with a base type of evidence
   where it can be composed of evidence as a sum
   or product. Still unsure how this differs from
   the other type of Inductive request definition *)

Inductive request : Type :=
| EV (t : term)
| SUM (t1 t2 : request)
| PROD (t1 t2 : request).

Theorem request_comm : forall (r1 r2 : request),
    SUM r1 r2 = SUM r2 r1.
Proof.
  intros r1. 
  induction r1.
  + intros. simpl.
Admitted.

    
(* We have now defined request as type SET *)
(* We need it to be communitive for SUM and PROD so
   order doesnt matter *)


Definition protocol := term.

Check request.

Definition myrequest0 := EV (myterm1).
Definition myrequest1 := EV (myterm3).
Definition myrequest2 := SUM (myrequest1) (myrequest0).
Definition myrequest3 := SUM (EV (KIM 3)) (EV (KIM 10)).
Definition myrequest4 := SUM (EV (KIM 10)) (EV (KIM 3)).

(*Definition myrequest3 := request (myterm1).*)

Definition myprotocol1 := PAR (KIM 3) (USM 3).

(* A protocol is  a list of terms 
   But those terms can be arranged in certain ways
   like parallel execution, *)

Definition proposal := list protocol.

Notation "x :: l" := (cons x l)
                     (at level 60, right associativity).
Notation "[ ]" := nil.
Notation "[ x ; .. ; y ]" := (cons x .. (cons y nil) ..).

(* What about examples of protocols? *)
(* Not sure which definition works? *)

(* Definition proposal := (request) -> protocol. *)

(* Options to match a request with are nothing,
   evidence, sum, product. 

   When nothing, go to the empty list, otherwise, 
   add to the front of the list.
 *)

Inductive R_id : Type :=
| R_ID (r : request).

Check R_id.

(* Definition eqb_id (t1 t2 : id) :=
  match t1, t2 with
  | ID t1, ID t2 => Same_set t1 t2
  end. *)

(* Two ways to construct partial map, either empty or using record with an existing 
   partial map to construct a key-to-value mapping *)

(* For now, we will request a term. The map will be built upon terms that can be requested.
   You can look up the requested term in the map and the request protocol will be 
   returned. *)

Inductive protocol_map : Type :=
| R_empty
| R_record (i : R_id) (p : protocol) (m : protocol_map).

(* Where each entry of the map is
   an ID that is the request *)

(* For now we will assume there is only 
   one term being requested at a time *)

Definition my_protocol_map_base := R_record (R_ID (EV (KIM 3))) (KIM 3) (R_empty).
Check my_protocol_map_base.

Definition R_update (d: protocol_map) (i : R_id) (t_value : protocol) : protocol_map :=
  R_record i t_value d.

Definition my_partial_map_1 := R_update (my_protocol_map_base) (R_ID (EV (USM 3))) (SEQ (USM 3) (KIM 3)).

(* Now we need to be able to find the value with the key. *)

Inductive requestoption : Type :=
| R_Some (p : protocol)
| R_None.

(* Now we need the option to return none. This can be done by seeing 
   if the two terms are equal. But we need an equality function to 
   tell if they are the same where the equality function returns
   the bool true if they are the same. *)

(* term is of the type SET. What equality relations hold over 
   set? *) 

Check request.

Definition conditional_eq {A} (x y : A) := x = y.
Check conditional_eq.

(* Definition eq_request (r1 r2 : request) := forall a : term , In a r1 <-> In a r2. *)

Fixpoint eq_term (t1 t2 : term) : bool :=
match t1 with
| KIM x1 => match t2 with
            | KIM x2 => if x1 =? x2 then true else false
            | _ => false
            end
| USM x1  => match t2 with
            | USM x2 => if x1 =? x2 then true else false
            | _ => false
            end
| AT p1 x1 => match t2 with
              | AT p2 x2 => if p1 =? p2 then eq_term x1 x2 else false
              | _ => false
              end
| SEQ x1 x2 => eq_term x1 x2
| PAR x1 x2 => eq_term x1 x2
| SIG x1 => match t2 with
            | SIG x2 => eq_term x1 x2
            | _ => false
            end
end.

Compute eq_term (KIM 3) (KIM 3).
Compute eq_term (KIM 3) (USM 3).

Fixpoint eq_request (r1 r2 : R_id) : bool :=
  match r1, r2 with
  | R_ID (EV x1) , R_ID (EV x2) => if eq_term x1 x2 then true else false
  | R_ID (SUM x1 x2) , R_ID (SUM x3 x4) => false (* if eq_request (R_ID x1) (R_ID x3)
                                           then true (* eq_request (R_ID x2) (R_ID x4)*)
                                           else false *)
  | R_ID (PROD x1 x2), R_ID (PROD x3 x4) => false (* if eq_request (R_ID x1) (R_ID x3)
                                            then true (* eq_request (R_ID x2) (R_ID x4)*)
                                            else false *)
  | _ , _ => false
  end.

Compute eq_request (R_ID myrequest1) (R_ID myrequest2).
Compute eq_request (R_ID (EV (KIM 1))) (R_ID (EV (KIM 1))).
Compute eq_request (R_ID myrequest2) (R_ID myrequest4). (* These should be equal *)

(* The problem is with the sum and prod parts. 
   But I'm not quite sure what we can do to 
   eliminate. It must recurse for each element
   of sum and prod to make sure they match. 
   But the thing about sum and prod is that x1 can
   either match x3 or x4. So how to communicate
   that is tricky. *)

(* Prove that the sets of sum and prod are communitive!!!!! *) 

(* ERROR : cannot guess decreasing argument of fix *)

(*Fixpoint eq_request (r1 r2 : R_id) : bool :=
  match r1  with
  | R_ID (EV x1) => match r2 with
                    | R_ID (EV x2) => if eq_term x1 x2 then true else false
                    | _ => false
                    end
  | R_ID (SUM x1 x2) => match r2 with
                        | R_ID (SUM x3 x4) => if (eq_request (R_ID x1) (R_ID x3))
                                              then (eq_request (R_ID x2) (R_ID x4))
                                              else false 
                        | _ => false
                        end 
  | R_ID (PROD x1 x2) => match r2 with
                         | R_ID (PROD x3 x4) => if (eq_request (R_ID x1) (R_ID x3))
                                                then (eq_request (R_ID x2) (R_ID x4))
                                                else false
                         | _ => false
                         end 
  end. *)              

Fixpoint R_find (x : R_id) (d : protocol_map) : requestoption :=
  match d with
  | R_empty => R_None
  | R_record y r d' => if eq_request x y
                     then R_Some r
                     else R_find x d'
  end.

(* How does request shape into the list??
   Should we be storing values somewhere??  *) 
  

(* After a proposal is generated, the appraiser must then select 
   the appropriate protocol for the attestation manager. 
   This implies there must be some notion of best and some
   notion of worst and that the protocols must be ordered.

   This brings me back to my inital thoughts that I have no idea
   where the notion of ordering should begin. Somehow we must 
   define a hierarcy of protocols in order to make the 
   decision. Maybe a function is the best way to go about 
   establishing an ordering. *)

(* Things to discuss
   1. properties of request
   2. why two requests can't be equal
   3. where are we saving the examples?
      Is there a way to save examples and import them from a file?
 *)

Fixpoint targ_priv_poly (p : protocol) : bool :=
  match p with
  | KIM x => true
  | _ => false
  end.

(* Defining like this wouldnt make it situationally dependent *)

