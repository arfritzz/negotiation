Require Import Omega.
Require Import List.
Require Import Lists.ListTactics.
Require Import Ensembles.
Require Import String.
(*Require Import Poset.*)

(* Before understanding a request, a SA must
   be established using ISAKMP. The goal of
   ISAKMP is to define a procedure for authenticating
   a communicating peer as well as a procedure for key
   generation techniques.

   This is done through a series of headers that describe
   the payload types, and exchange types

 *)

(* Coq Inductive terms are used to create a data structure *)

Inductive SA : Type :=
| authMethod (a : string)
| encrypMethod (e : string)
| HMAC (h : string)
| DHgroup (g : nat)
| time (t : nat).


(* What can you prove about SA??*)
(* I want the security association to produce 
   a natural number, like that is is signed by a natural
   number. How do I do that? *)

Definition place := nat.

Inductive term : Type :=
| KIM : nat -> term
| USM : nat -> term
| AT : place -> term -> term
| SEQ : term -> term -> term
| PAR : term -> term -> term
| SIG : term -> term.

Definition myterm1 := (KIM 3).
Definition myterm2 := (AT 4).
Definition myterm3 := (SIG (KIM 3)).
Definition myterm4 := (SEQ (KIM 3)).
Definition myterm5 := (PAR (SIG (USM 4))).

(* A request is generated by the appraiser and 
   holds something in it. It is not necessarily evidence yet
   but something else that dictates was the appraiser wants
   to know about the target. For now, I will say that the request
   is composed of certificates that enforce the privacy policy
   of the appraiser. *)

(*Inductive request (term : Type) := 
| EV : term -> (request term)
| SUM : term -> (request term) -> (request term)
| PROD : term -> (request term) -> (request term). *)

(* I built a data structure with a base type of evidence
   where it can be composed of evidence as a sum
   or product. Still unsure how this differs from
   the other type of Inductive request definition *)

Inductive request : Type :=
| EV (t : term)
| SUM (t1 t2 : request)
| PROD (t1 t2 : request).      
    
(* Now, how to create requests *)

Check request.

Definition myrequest1 := EV (myterm1).
Definition myrequest := EV (myterm3).
Definition myrequest2 := SUM (myrequest1) (myrequest).
(*Definition myrequest3 := request (myterm1).*)

(* A protocol is  a list of terms 
   But those terms can be arranged in certain ways
   like parallel execution, *)

Definition proposal := list term.

Notation "x :: l" := (cons x l)
                     (at level 60, right associativity).
Notation "[ ]" := nil.
Notation "[ x ; .. ; y ]" := (cons x .. (cons y nil) ..).

(* What about examples of protocols? *)
(* Not sure which definition works? *)

(* Definition proposal := (request) -> protocol. *)

Fixpoint evalrequest (r : request) : proposal :=
  match r with
  | EV (KIM _) => myterm1 :: []
  | EV (USM _) => myterm1 :: []
  | EV (AT _ _) => myterm1 :: []
  | EV (SEQ _ _) => myterm1 :: []
  | EV (PAR _ _) => myterm1 :: []
  | EV (SIG _) => myterm1 :: []
  | SUM r1 r2 => match r1 with
                 | EV r1 => match r2 with
                            | EV r2 => EV r1 :: EV r2
                            | _ => EV r1 :: evalrequest r2
                            end
                 end      
  end.

(* How does request shape into the list?? *)

(* If I wanted to say "Compute request 5" idk how to do that
   or where I defined these things in this language. 
  
   Somewhere in PLUS someone came up with the notition of 
   (S (S n)) but where/how did they think to do this? *)

(* After a proposal is generated, the appraiser must then select 
   the appropriate protocol for the attestation manager. 
   This implies there must be some notion of best and some
   notion of worst and that the protocols must be ordered.

   This brings me back to my inital thoughts that I have no idea
   where the notion of ordering should begin. Somehow we must 
   define a hierarcy of protocols in order to make the 
   decision. Maybe a function is the best way to go about 
   establishing an ordering. *)

